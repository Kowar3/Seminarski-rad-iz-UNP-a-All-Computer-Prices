---
title: "projekat"
author: "Bojan i Mateja"
date: "2025-11-05"
output: html_document
---

# UVOD

# Učitavanje potrebnih biblioteka

```{r}
  library(tidyverse)
  library(ggplot2)
  library(scales)
  library(dplyr)
  library(corrplot)
  library(ggcorrplot)
  library(stringr)
```

# Ucitavanje skupa podataka i prikaz osnovnih stvari

```{r}
data = read.csv("computer_prices_all.csv")
names(data) 
str(data)
```

# Analiza raspodele ciljne promenljive

```{r}
summary(data$price)
```

# Histogram ciljne promenljive price

Histogram prikazuje raspodelu ciljne promenljive price i ovde takođe možemo videti 
da raspodela nije simetrična, već pozitivno asimetrična. Kao što je malopre 
spomenuto najveći broj uređaja se nalazi u srednjem cenovnom rangu, manji u nižem, 
a najmanji broj uređaja u skupljem cenovnom rangu. Ovo je i očekivano jer većina 
korisnika kupuje upravo uređaje srednjeg ranga. 

```{r}
ggplot(data, aes(x = price)) +
  geom_histogram(bins = 50, fill = "#1f78b4", color = "black", alpha = 0.7) +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  labs(
    title = "Distribucija promenljive 'price'",
    x = "Cena uređaja (USD)",
    y = "Broj uređaja"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```

# Boxplot ciljne promenljive price

Boxplot i potvrđuje ono što smo videli na histogramu i ovde vidimo tačke koje na 
histogramu nisu bile prikazane, jer ih je jako malo sa visokom cenom i te tačke 
potencijalno predstavljaju outlier-e. Oni mogu značajno da utiču na to koliko je naš 
model dobar što će i biti provereno kasnije.
Pošto linearna regresija pretpostavlja da je raspodela ciljne promenljive približno 
normalna, a kod nas to nije slučaj i  zbog toga će kasnije biti primenjena logaritamska
transformacija. Ona približava raspodelu normalnoj tj. čini da histogram ima zvonastu 
strukturu. Samim tim se smanjuje uticaj skupljih uređaja i model postaje bolji i stabilniji.

```{r}
ggplot(data, aes(y = price)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  scale_y_continuous(labels = comma) +
  labs(
    title = "Boxplot cene uređaja",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```

# VIZUELIZACIJA PODATAKA

# Distribucija tipova uređaja

```{r}
ggplot(data, aes(device_type)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(
    title = "Distribucija tipova uređaja",
    x = "Tip uređaja",
    y = "Broj uređaja"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```
  
Na grafiku iznad se vidi da u skupu ima više laptopova nego desktop računara, što je i očekivano jer su laptopovi danas mnogo zastupljeniji na tržištu. Ova razlika nije problematična, ali je važno da se zabeleži, već u početnoj analizi, jer nam govori kakav je sastav podataka pre daljeg čišćenja i obrade. U ovoj promenljivoj nema nelogičnosti ili vrednosti koje bi trebalo uklanjati odmah ukloniti.

# Distribucija CPU tier kategorija

```{r}
ggplot(data, aes(cpu_tier)) +
  geom_bar(fill = "orange", color = "black") +
  labs(
    title = "Distribucija CPU tier kategorija",
    x = "CPU tier",
    y = "Broj uređaja"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```

Raspodela CPU tier vrednosti izgleda prilično prirodno: najviše uređaja pripada srednjim kategorijama (tier 2–4), dok su najjači i najslabiji procesori očekivano ređi. Ovo nam govori da dataset dobro pokriva različite nivoe procesorske snage i da u ovoj promenljivoj nema očiglednih grešaka ili nelogičnosti koje bi trebalo odmah uklanjati. 

# Distribucija GPU tier kategorija

```{r}
ggplot(data, aes(gpu_tier)) +
  geom_bar(fill = "firebrick", color = "black") +
  labs(
    title = "Distribucija GPU tier kategorija",
    x = "GPU tier",
    y = "Broj uređaja"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```
  
Na grafiku se vidi da i raspodela GPU tier vrednosti izgleda očekivano tj. najzastupljenije su srednje kategorije, dok najjače grafičke kartice imaju znatno manje primeraka. Ovo je tipičan raspored za tržište uređaja i ne ukazuje na bilo kakve greške u podacima i nema nikakvih vrednosti koje bi trebalo odmah ukloniti.

# Distribucija operativnih sistema

```{r}
ggplot(data, aes(os)) +
  geom_bar(fill = "steelblue", color = "black") +
  labs(
    title = "Distribucija operativnih sistema",
    x = "Operativni sistem",
    y = "Broj uređaja"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust = 0.5, face = "bold"))
```
  
Na grafiku se vidi da i raspodela GPU tier vrednosti izgleda očekivano tj. najzastupljenije su srednje kategorije, dok najjače grafičke kartice imaju znatno manje primeraka. Ovo je tipičan raspored za tržište računara i ne ukazuje na bilo kakve greške u podacima i nema nikakvih vrednosti koje bi trebalo odmah ukloniti.

# Grafik cene uređaja u odnosu na godinu izdavanja, godine se krecu od 2018 do 2025

Na osnovu boxplot-ova možemo videti da su medijane uglavnom slične kroz godine ili 
se minimalno povećavaju. Iako bi se trebalo pretpostaviti da će noviji uređaji biti 
malo skuplji ovo je sasvim u redu. Postoji dosta tačaka koje odskaču od većine, to 
su sve verovatno profesionalni uređaji sa veoma jakim performansama i skupim 
komponentama, ali će kasnije biti ispitani. Iako modeli srednjeg cenovnog ranga 
blago rastu jeftini modeli uglavnom ostaju sličnih cena što znači da u tom delu ne 
dolazi do nekih većih promena.

```{r}
ggplot(data, aes(x = factor(release_year), y = price)) +
  geom_boxplot(fill = "#1f78b4", color = "black", alpha = 0.7, outlier.colour = "red") +
  labs(
    title = "Cena uređaja u odnosu na godinu izdavanja",
    x = "Godina izdavanja",
    y = "Cena (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

# Grafik cene u odnosu na tip uređaja

Na osnovu boxplot dijagrama možemo videti da postoji razlika u ceni između 
desktop računara i laptopova, ali nije velika. Medijana cene laptopova je nešto 
veća što je i očekivano, jer laptopovi imaju integrisane komponente i prenosivi su, 
pa su skuplji od računara. Postoji dosta cena koje odskaču od većine (srednje klase) 
i to su verovatno profesionalni računari i gaming laptopovi.

```{r}
ggplot(data, aes(x = device_type, y = price, fill = device_type)) +
  geom_boxplot(alpha = 0.8, outlier.colour = "red", outlier.shape = 8) +
  labs(
    title = "Cena uređaja u odnosu na tip uređaja",
    x = "Tip uređaja",
    y = "Cena (USD)"
  ) +
  scale_fill_manual(values = c("#1f78b4", "#33a02c")) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "none"
  )
```

# Grafik cene uređaja u odnosu na RAM memoriju

Sa boxplot-ova možemo videti da postoje samo određene vrednosti RAM memorije. Medijane uglavnom rastu sa porastom cene i to tek na po 24 ili 32 GB ram-a, npr. medijana za 32, 40 i 48 GB ram-a je skoro identična tek se za 64 GB ram-a povećava. Postoji mnoštvo potencijalnih outlier-a, posebno u veličinama RAM memorije koje su i inače najčešće, 16, 32, 48 i 96 GB ram-a, ali su za sve vrednosti outlier-i u granicama normale i možemo zaključiti da cena dosta zavisi i od drugih prediktora, jer ovde imamo samo vrednosti količine RAM-a, nemamo podatke o tip-u, frekvenciji i slično. Npr. tokom godina se povećava brzina RAM-a u MHz-ima, pa bi bilo dobro to proveriti.

```{r}
ggplot(data, aes(x = factor(ram_gb), y = price)) +
  geom_boxplot() +
  labs(
    title = "Cena uređaja u odnosu na RAM memoriju",
    x = "RAM (GB)",
    y = "Cena (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
```

# Grafik cene uređaja u odnosu na broj jezgara procesora

Sa grafika se može videti da sa porastom broja jezgara blago raste i cena uređaja što 
je i logično jer broj jezgara je indikator procesorske moći. Takođe postoji nekoliko primera sa manje od 10 jezgara, a cenom preko 8000$ i verovatno je isti razlog kao za ove prethodne, a takođe je moguće da je došlo do nekih grešaka pri unosu, što je potrebno dodatno ispitati.

```{r}
ggplot(data, aes(x = factor(cpu_cores), y = price)) +
  geom_boxplot() +
  labs(
    title = "Cena uređaja u odnosu na broj jezgara procesora",
    x = "Broj jezgara procesora",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
```

# Grafik cene uređaja u odnosu na rang procesora

Sa grafika možemo videti boxplot-ove koji prikazuju cene uređaja u odnosu na klasu 
procesora koju imaju. 1 je najlošija, 6 je najbolja klasa. Medijana se porastom klase 
postepeno povećava, što je i logično, što je bolji procesor cena je veća. Za svaku 
kategoriju postoje potencijalni outlieri tj. cene dosta niže ili više od prosečnih za 
tu kategoriju, što je u redu , jer su druge komponente najverovatnije jeftinije. 
Postoje uređaji najviše klase, dosta jeftiniji od uređaja nižih klasa, to može značiti 
da je neka druga komponenta zaslužna za takvu cenu, a može biti i da su podaci pogrešno uneti.

```{r}
ggplot(data, aes(x = as.factor(cpu_tier), y = price)) +
  geom_boxplot(alpha = 0.7) +
  labs(
    title = "Cena uređaja u odnosu na CPU Tier",
    x = "CPU Tier (rang procesora)",
    y = "Cena (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```

# Grafik cene uređaja u odnosu na rang grafičke kartice

Sa grafika možemo videti kakve su cene uređaja u odnosu na grafičku karticu i 
takođe kao i kod procesora postoji 6 kategorija i još pravilnije sa porastom klase 
raste i cena. Potencijalnih outliera ima, ali biće ispitani, posebno ovaj uređaj sa 
cenom od 7500$, a najlošijom klasom grafičke kartice. U globalu ova osobina je dosta 
bitna za krajnju cenu uređaja.

```{r}
ggplot(data, aes(x = as.factor(gpu_tier), y = price)) +
  geom_boxplot() +
  labs(
    title = "Cena uređaja u odnosu na GPU Tier",
    x = "GPU Tier (rang grafičke kartice)",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```

# Grafik cene uređaja u odnosu na tip memorije

Boxplot-ovi prikazuju zavisnost cene od tipa memorije, HDD je najstarija i najsporija, 
SSD novija od nje i brža, Hybrid je njihova kombinacija, a NVMe je najbrža i najbolja 
verzija SSD memorije. Ovo obeležje ne utiče značajno na cenu uređaja, medijane su 
skoro pa slične, malo je medijana niža kod HDD memorije što je i logično jer je to 
najsporija i najjeftinija memorija. Postoje uređaji sa velikom cenom, a najslabijom 
vrstom memorije, ali je verovatno ima dosta, jer su ostale komponente skuplje i jače. 
Dobar primer je RAM, ako imamo mnogo RAM-a, onda nam brzina eksterne memorije nije 
presudna, te je bolje uzeti sporiju i jeftiniju eksternu memoriju.

Prirodno pitanje koje se postavlja je da li bi nam multivarijanta analiza tipa eksterne memorije zajedno sa njenom veličinom u odnosu na cenu dala neke bolje rezultate. Ispostavlja se da nam ne bi dala nikakvo poboljšanje, najviše što bismo dobili time je potvrdu prethodno ustanovljenih trendova.

```{r}
ggplot(data, aes(x = storage_type, y = price)) +
  geom_boxplot() +
  labs(
    title = "Cena uređaja u odnosu na tip skladišta podataka",
    x = "Tip skladišta (storage_type)",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```

# Grafik cene uređaja u odnosu na rezoluciju ekrana

Sa grafika vidimo da medijana blago raste sve do rezolucije 2880x1800, nakon toga 
opada i na samom kraju ponovo raste. Kod svake rezolucije postoje jako skupi modeli 
što je sasvim u redu. Takođe je bitno napomenuti da ima nekoliko uređaja sa izuzetno 
malom cenom oko 500$, a sa najvećom rezolucijom 3840X2160, što ne prati trend nikako 
i može predstaviti veliki problem u treniranju modela.

```{r}
ggplot(data, aes(x = resolution, y = price)) +
  geom_boxplot(fill = "lightblue", color = "black") +
  labs(
    title = "Cena uređaja u odnosu na rezoluciju ekrana",
    x = "Rezolucija ekrana",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 25, vjust = 1, hjust = 1)
  )
```

# Grafik cene u odnosu na kapacitet baterije uređaja

Znamo da su uređaji sa 0Wh baterije računari, a svi ostali su laptopovi. Sa grafika vidimo samo da je medijana za računare malo niža od medijane za laptopove, a sa povećanjem broja Wh medijane su skoro identične, tako da nam ovaj prediktor uopšte nije bitan.

```{r}
ggplot(data, aes(x = factor(round(battery_wh, -1)), y = price)) +
  geom_boxplot(outlier.alpha = 0.2, fill = "skyblue", color = "darkblue") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Cena uređaja u odnosu na kapacitet baterije",
    x = "Kapacitet baterije (Wh, zaokruženo na 10)",
    y = "Cena (USD)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

# Grafik cene uređaja u odnosu na brzinu procesora

Sa grafika vidimo da veza cene i brzine procesora i nije bas linearna, postepeno 
raste do određenog dela, ali ima i dosta uređaja sa velikom brzinom procesora ,a 
malom cenom, u redu je ako su im npr. druge komponente jeftinije ili može takođe 
zavisiti od proizvođača procesora.

```{r}
ggplot(data, aes(x = factor(cpu_base_ghz), y = price)) +
  geom_violin(fill = "purple") +
  labs(
    title = "Cena uređaja u odnosu na brzinu procesora",
    x = "Osnovna brzina procesora (GHz)",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )
```

# Grafik cene uređaja u odnosu na proizvođača procesora

Možemo videti cene uređaja u odnosu na proizvođača procesora. Apple prednjači u 
odnosu na AMD i Intel što je i očekivano, jer oni obično i dolaze sa skupljim 
komponentama. Svi imaju dosta skupe uređaje što je potrebno ispitati, posebno 
uređaje iznad 9 hiljada dolara, kojih je samo nekoliko.


```{r}
ggplot(data, aes(x = cpu_brand, y = price)) +
  geom_boxplot() +
  labs(
    title = "Cena uređaja u odnosu na proizvođača procesora",
    x = "Brend procesora",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# Grafik cene u odnosu na operativni sistem uređaja

Medijana ChromeOS je najniža što je i očekivano jer je relativno mlad operativni 
sistem, sa ne toliko širokom upotrebom, a uređaji sa macOS su očekivano najskuplji 
zbog cene svojih komponenti i svog uticaja na tržištu. Uređaja sa dosta većim 
cenama ima svugde, najviše sa Windows operativnim sistemom, jer je on najpoznatiji 
i najkorišćeniji operativni sistem. Izdvaja se uređaj koji ima macOS i cenu ispod 
1000$ i uređaj sa ChromeOS i cenom preko 6000$. To su ekstremne vrednosti, koje bi 
mogle značajno da umanje preciznost modela.

```{r}
ggplot(data, aes(x = os, y = price)) +
  geom_boxplot() +
  labs(
    title = "Cena uređaja u odnosu na operativni sistem",
    x = "Operativni sistem",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# Grafik cene u odnosu na proizvođača uređaja

Medijane su uglavnom slične, Razer ima malo veću od ostalih, a Apple dosta ali 
i očekivano, Apple uređaji su uvek najskuplji. Kod HP, Lenovo i MSI brenda postoje 
modeli skuplji od 9000$ što je potrebno ispitati i potencijalni outlieri jesu i 
modeli Dell i Razer marke koji su jeftiniji od 700$ dolara. Ovo je važan prediktor, 
ali je uglavnom dosta bitniji u kombinaciji sa drugim prediktorima.

```{r}
ggplot(data, aes(x = brand, y = price)) +
  geom_boxplot() +
  theme_minimal() +
  labs(
    title = "Cena uređaja u odnosu na proizvođača",
    x = "Brend uređaja",
    y = "Cena uređaja (USD)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# Kombinacije podataka radi boljeg prepoznavanja trendova

# Uticaj marke procesora na cenu po rangu

```{r}
ggplot(data, aes(x = cpu_tier, y = price, color = cpu_brand)) +
  geom_point(alpha = 1/3) +
  facet_wrap(~ cpu_brand) +
  theme_minimal() + labs(
    title = "Uticaj marke procesora na cenu po rangu",
    x = "Rang procesora (tier)",
    y = "Cena u dolarima"
  )+
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# Uticaj marke i ranga grafičke kartice na cenu

```{r}
ggplot(data, aes(x = gpu_tier, y = price, color = gpu_brand)) +
  geom_point(alpha = 1/3) +
  facet_wrap(~ gpu_brand) +
  theme_minimal() + labs(
    title = "Uticaj marke i ranga grafičke kartice na cenu",
    x = "Rang grafičke kartice (tier)",
    y = "Cena u dolarima"
  )+
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# Uticaj ranga procesora i ranga grafičke kartice na cenu

```{r}
ggplot(data, aes(x = cpu_tier, y = price, color = gpu_tier)) +
  geom_point(alpha = 1/3) +
  facet_wrap(~ gpu_tier) +
  theme_minimal() + labs(
    title = "Uticaj ranga procesora i ranga grafičke kartice na cenu",
    x = "Rang procesora (tier)",
    y = "Cena u dolarima"
  )+
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# Uticaj VRAM memorije i ranga grafičke kartice na cenu uređaja

```{r}
ggplot(data, aes(x = vram_gb, y = price, color = factor(gpu_tier))) +
  geom_jitter(alpha = 0.6, width = 0.3) +
  scale_color_viridis_d() +
  labs(
    title = "Uticaj VRAM memorije i ranga grafičke kartice na cenu uređaja",
    x = "VRAM (GB)",
    y = "Cena (USD)",
    color = "GPU tier"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# Uticaj RAM memorije i godine izlaska uređaja na cenu na cenu uređaja

```{r}
ggplot(data, aes(x = ram_gb, y = price, color = release_year)) +
  geom_jitter(alpha = 0.4) +
  scale_color_viridis_c() +
  labs(
    title = "Uticaj RAM memorije i godine izlaska uređaja na cenu na cenu uređaja",
    x = "RAM (GB)",
    y = "Cena (USD)",
    color = "Godina izlaska"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

# ČIŠĆENJE I OBRADA PODATAKA

```{r}
datav2 = data
```

Za svaki slučaj radimo sa rezervom originalnog skupa, ako nesto pogrešimo imamo original podatke netaknute

# 1) provera NA vrednosti

```{r}
colSums(is.na(datav2))
```

Vidimo da u datasetu ne postoje NA tj. vrednosti koje fale već su svi podaci za svih 100k redova popunjeni

# 2) pogrešno unete vrednosti

Analizom skupa podataka vizuelno i analizom grafika iz prethodnog koraka nisu oučene neke pogrešne vrednosti npr. tip uređaja da negde bude Device negde device ili uređaj od 100kg, negativna vrednost cene, memorije ili nečeg sličnog

# 3) nelogične vrednosti

```{r}
nrow(filter(datav2, os == "macOS" & price < 1000))
```

Sa grafika odnosa cene i os-a su nam bili sumnjivi uređaji sa macOS jeftiniji od 1000$ i sada vidimo da su oni uglavnom od nekog drugog proizvođaca što u stvarnosti nije moguće

```{r}
macos_nije_apple = datav2 %>% filter(os == "macOS" & brand != "Apple")
nrow(macos_nije_apple)
```

Postoji 16032 reda kojima je proizvođač uređaja neka kompanija koja nije apple, a imaju mac os što nije moguće i nije ni zakonski, apple ne dozvoljava instaliranje mac os na proizvodima drugih kompanija ako se ne gleda samo zvanično, postoje zajednice koje se bave podizanjem mac os na ne-apple računare i laptopove, ali to ništa nije oficijalno i ovde su podaci samo o novim uređajima iako je 16032 dosta dobar deo od 100k podaci su nerealni i netačni, pa će biti uklonjeni

```{r}
datav2 = datav2 %>% filter(!(os == "macOS" & brand != "Apple"))
nrow(datav2)
```

Sada nam ostaje 83968, uklonjeno je oko 16% postojećih podataka znamo i da apple uređaji ne mogu imati neki drugi os osim ako npr imaju intel procesor što je i bio slučaj do pre nekoliko godina, pa ćemo proveriti i takve

```{r}
ggplot(data = datav2) + geom_point(mapping = aes(x = os, y = brand)) + theme_minimal() + labs(
  title = "Operativni sistemi na različitim proizvođačima",
  x = "Operativni sistem",
  y = "Marka proizvođača"
) +
theme(
  plot.title = element_text(hjust = 0.5, face = "bold")
)

apple_intel_procesor = datav2 %>% filter(brand == "Apple" & cpu_brand == "Intel")
nrow(apple_intel_procesor)
```

Apple uređaja sa intel procesorima nema

```{r}
apple_apple_procesor = datav2 %>% filter(brand == "Apple" & cpu_brand == "Apple")
nrow(apple_apple_procesor)
```

Apple uređaja imamo 11915 i pošto ih nema sa intel procesorom, tražimo sve koji nemaju macos

```{r}
apple_nije_macos = datav2 %>% filter(brand == "Apple" & os != "macOS")
nrow(apple_nije_macos)
```

Ovakvih redova ima 9740, ti podaci nisu realni i brišemo ih, uklonjeno je oko 11,5% postojećih podataka

```{r}
datav2 = datav2 %>% filter(!(brand == "Apple" & os != "macOS"))
nrow(datav2)
```

Za prethodne 2 stvari smo koristili domensko znanje, koje nam je mnogo pomoglo da uočimo nepravilnosti i da ih potom ispitamo.

Iako na prvi pogled deluje zabrinjavajuće to što je uklonjeno ~26% podataka, ova odluka je po nama opravdana, jer su ti zapisi bili logički i tehnički nemogući. Radi se o uređajima koji imaju macOS instaliran na hardveru koji nije proizveo Apple, što je ne samo nerealan scenario, već je to i zakonski zabranjeno, pa takvi uređaji ne mogu da postoje. Drugi deo nelogičnih zapisa činili su uređaji koje je navodno Apple proizveo, ali koji nemaju macOS, što takođe nije moguće, jer Apple ne isporučuje svoje proizvode ni sa jednim drugim operativnim sistemom. Mogli smo takve uređaje svrstati u posebnu kategoriju poput “unknown” ili popuniti vrednosti nekim pretpostavkama, ali bi to značilo da u model unosimo veštačke informacije koje ne postoje u stvarnosti i koje bi potencijalno narušile tačnost analize i predikcija. Upravo zato odlučili smo da ove podatke u potpunosti uklonimo, jer se ne radi o gubitku validnih informacija, već o eliminaciji netačnih i nelogičnih redova čije bi prisustvo verovatno smanjilo kvalitet modela.

```{r}
ggplot(data = datav2) + geom_point(mapping = aes(x = os, y = brand)) + theme_minimal() + labs(
  title = "Operativni sistemi na različitim proizvođačima",
  x = "Operativni sistem",
  y = "Marka proizvođača"
)
```

Proveravamo još neke nelogične vrednosti

```{r}
desktop_with_battery = datav2 %>% filter(device_type == "Desktop" & battery_wh > 0)
nrow(desktop_with_battery)
laptop_no_battery = datav2 %>% filter(device_type == "Laptop" & battery_wh == 0)
nrow(laptop_no_battery)
```

Provera da li postoji računar sa baterijom, nema ih ili možda laptop bez baterije, takođe ih nema

# 4) analiza i potencijalno izbacivanje outlier-a

```{r}
preskupi_2021 = datav2 %>% filter(release_year == 2021 & price > 9000)
nrow(preskupi_2021)
```

Sa grafika zavisnosti cene od godine izdavanja uređaja u 2021 postoji uredjaj sa cenom od preko 9000$, a te godine još nisu postojale toliko skupe komponente, pa bi trebalo da sklonimo ovaj uređaj

Pošto je ovde rezultat 0 znači da je ovaj uređaj već sklonjen ranije zbog nekih nelogičnih vrednosti, što dodatno potrvđuje da ovaj uređaj nije bio realan da postoji

```{r}
preskupi_laptopovi = datav2 %>% filter(device_type == "Desktop" & price > 8000)
preskupi_racunari = datav2 %>% filter(device_type == "Laptop" & price > 10000)
nrow(preskupi_laptopovi)
nrow(preskupi_racunari)
```

Sa grafika zavisnosti cene od tipa uređaja ostavićemo laptopove koji koštaju do 10000$, jer oni sadrže integrisane i skupe komponente, pa i mogu mnogo koštati (oni preko 10k su već nerealni sa bilo kakvim komponentama i brišemo ih) 
Računari su jeftiniji od laptopova tako da do 8000$ je maksimalna granica otprilike koliko mogu da koštaju, pa ćemo sve sa cenom preko 8000$ skloniti

```{r}
datav2 = datav2 %>% filter(!((device_type == "Desktop" & price > 8000) | (device_type == "Laptop" & price > 10000)))
```

Obrisali smo 4 ovakva podatka

Sa grafika zavisnosti cene od ranga grafičke kartice postoje uređaji koji koštaju preko 6000$, a najnižeg su nivoa grafičke kartice, što nije moguće, kakve god da su im druge komponente i ovaj podatak se dosta ističe od drugih, pa ćemo ga obrisati

```{r}
datav2 = datav2 %>% filter(!(gpu_tier == 1 & price > 6000))
```

Obrisali smo jedan podatak

```{r}
jeftini_ogromna_rezolucija = datav2 %>% filter(resolution %in% c("3440x1440", "3840x2160") & price < 500)
nrow(jeftini_ogromna_rezolucija)
```

Sa grafika zavisnosti cene od rezolucije ekrana postoje uređaji sa maksimalnom rezolucijom i cenom ispod 500$, što je nemoguće kakve god da su druge komponente, pa ćemo ih obrisati

```{r}
datav2 = datav2 %>% filter(!(resolution %in% c("3440x1440", "3840x2160") & price < 500))
```

Obrisana su 2 podatka

```{r}
prejeftini_macovi = datav2 %>% filter(os == "macOS" & price < 700)
nrow(prejeftini_macovi)
```

Sa grafika zavisnosti cene od os-a postoje uređaji sa macOS ispod 700 što je nerealno jeftino čak i za polovne modele, a ovde pričamo o novima

Rezultat ovog koda će biti 0 takvih podataka, jer je to bio uređaj koji je prethodno uklonjen zbog nečeg drugog, što nam drugi put potvrđuje da ovaj uređaj nije realan da postoji

```{r}  
preskupi_chromeos = datav2 %>% filter(os == "ChromeOS" & price > 9000)
nrow(preskupi_chromeos)
```

Sa grafika zavisnosti cene od os-a vidimo da postoje uređaji koji imaju chromeOS koji imaju slabiji uređaji i uopšteno ga nema kod skupljih, rezultat za uređaj sa ovim os-om kakve god da su druge komponente, pa ćemo obrisati

Rezultat ovog koda jeste 0, što nam govori da ovaj podatak i treba izbaciti, što smo ovde i drugi put dokazali, jer su uređaji sklonjeni prilikom nekog od prethodnih čišćenja podataka

Nakon svih čišćenja podataka ostalo je 74221 podataka, odnosno uklonjeno je oko 26% podataka

# EDA

```{r}
numericke_kolone = datav2 %>% select_if(is.numeric)
names(numericke_kolone)
```

Izdvajamo samo kolone koje su numeričke, jer samo između njih možemo videti korelaciju, ima ih 20
korelacija je statistička mera koja opisuje jačinu i smer linearne povezanosti između dve ili više numeričkih varijabli, tačnije da li se promenom jedne varijable menja i druga

Bliže 1 je sve više pozitivna korelacija tj. kako jedna raste i druga raste, kako je bliže -1, kako jedna raste druga opada, negativna korelacija, bliže 0, sve je manja povezanost

```{r}
matrica_korelacije = cor(numericke_kolone, use = "complete.obs")
matrica_korelacije
```

Izračunavanje korelacije između svaka dva numerička obeležja i prikaz rezultata

```{r}
sort(matrica_korelacije[,"price"], decreasing = TRUE)
```

Ispis matrice koja prikazuje kolika je korelacija svakog numeričkog atributa sa price, sortirano opadajuće, da se odmah vidi koja su obeležja pojedinačno najbolja

```{r}
ggcorrplot(
  matrica_korelacije,
  hc.order = TRUE,           
  type = "full",             
  lab = TRUE,                
  lab_size = 2.5,            
  colors = c("red", "white", "blue"),
  outline.col = "gray",
  ggtheme = ggplot2::theme_minimal()
) +
labs(
  title = "Korelaciona matrica numeričkih promenljivih",
  subtitle = "Prikaz svih parova promenljivih (gornji i donji trougao)"
) +
theme(
  plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
  plot.subtitle = element_text(hjust = 0.5, size = 12),
  axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
)
```

Iscrtavanje malopre pomenute matrice, samo grafički kako bi se lakše posmatralo
što je više plavo jača je pozitivna korelacija, što je više crveno to je više negativno korelisano
donji i gornji trougao su preslikvanje, pa su isti, ali su nacrtana oba kako bi grafik bio lepši i naravno na dijagonali su sve jedinice, svako obeležje ima korelaciju 1 sa samim sobom što je i logično

Jake pozitivne korelacije sa ciljnom promenljivom su gpu_tier, cpu_tier, ram_gb, cpu_cores, cpu threads, cpu_baze_ghz, cpu_boost_ghz i vram_gb
cena najviše zavisi od hardverskih perfomansi CPU, GPU, RAM i slično i to će biti naši glavni prediktori za budući model
slabe pozitivne korelacije su sa storage_gb, release_year, refresh_hz, bluetooth, warranty_months i slično. 
same po sebi ne utiču mnogo, ali sa nečim u kombinaciji ovo se možda može povećati
negativne korelacije su sa weight_kg, display_size_in, psu_watts i druge. Vrednosti su uglavnom dosta bliže 0, tako da i nema neke velike povezanosti
snažne međusobne korelacije jesu između cpu_base_ghz i cpu_boost_ghz, cpu_tier sa bilo čim iz cpu dela, gpu_tier i vram i druge, uzimaćemo po našoj proceni bitniju od svake dve kako ne bismo došli do multikolinearnonsti
kada su dve ili vise promenljive međusobno visoko korelisane kazemo da su multikolinearne

sve kategorijske promenljive pretvaramo u factor. Factor je poseban tip promenljive koji služi da predstavi kategorijske promenljive, kažemo R-u da ova obeležja nemaju numeričko značenje već su podaci podeljeni po grupama
umesto da kategorijske promenljive budu string-ovi pretvaraju se u factor kako bi grafici mogli da se pravilno iscrtaju, da se podaci lakse skladište i da bi mogle da se definišu i ordered promenljive
ordered znači da postoji prirodan redosled i bitno je kojim redom ide koja kategorija

```{r}
datav2$device_type = as.factor(datav2$device_type)
datav2$brand = as.factor(datav2$brand)
datav2$os = as.factor(datav2$os)
datav2$storage_type = as.factor(datav2$storage_type)
datav2$cpu_brand = as.factor(datav2$cpu_brand)
datav2$gpu_brand = as.factor(datav2$gpu_brand)
datav2$display_type = as.factor(datav2$display_type)
datav2$resolution = as.factor(datav2$resolution)
datav2$wifi = as.factor(datav2$wifi)
datav2$form_factor = as.factor(datav2$form_factor)
datav2$cpu_tier = factor(
  datav2$cpu_tier,
  levels = sort(unique(datav2$cpu_tier)),
  ordered = TRUE
)
datav2$gpu_tier = factor(
  datav2$gpu_tier,
  levels = sort(unique(datav2$gpu_tier)),
  ordered = TRUE
)
```
Imamo samo dve moguće vrednosti za device_type Desktop i Laptop pa ovo obeležje pretvaramo u factor, za ostala uglavnom isto

cpu_tier i gpu_tier pretvaramo u ordered obeležje, kategorijsko je i jako je bitan redosled

Obeležja poput model, i  ne pretvaramo, jer nisu previše bitni za model i ima hiljade i hiljade različitih kategorija, nema nekih kategorija, a numerička obeležja ostaju onakva kakva i jesu

Nakon iscrtavanja početnih grafika i njihove analize, čišćenja i sređivanja podataka i naravno uz pomoć domenskog znanja u EDA fazi izdvojićemo nekoliko grafika koje smatramo da su najbitniiji. Takođe uradićemo i ANOVA test kako bismo i statistički potvrdili ono što se vidi na grafiku. Test će biti urađen za obeležja cpu_tier i gpu_tier, jer su kategorijska i imaju više od 3 kategorije, što je idealno za ovaj test (za obeležja sa dve kategorije bi npr. t-test bio bolji).

ANOVA (Analysis of Variance) je statistička metoda koja se koristi da testira da li bar jedna grupa ima drugačiji prosek od ostalih. Ako je vrednost p < 0.05 to znači da postoje značajne razlike, u našem slučaju, u cenama između grupa.

# 1) Grafik cene u odnosu na rang procesora

```{r}
ggplot(datav2, aes(x = cpu_tier, y = price)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Cena u odnosu na CPU Tier",
       x = "CPU Tier", y = "Cena (USD)") +
  theme_minimal()
```

Boxplot-ovi nam pokazuju da cena jasno raste sa povećanjem ranga procesora, medijana se postepeno povećava.
svaki rang takođe može imati i skuplje i jeftinije uređaje, u zavisnosti od drugih komponenti, procesor je svakako jedna od najbitnijih komponenti uređaja, ali i jačina ostalih komponenti može znatno da smanji ili poveća cenu
kod većih rangova veći je i raspon cena, skuplji uređaji mogu biti raznih vrsta gaming uređaji, premium brendovi i slično, negde je jak procesor i ostale komponente su slabije, negde je obrnuto, tako da i cene koje odskaču su sasvim realne
cene koje odskaču kod nižih rangova su uglavnom gaming računari sa jakom grafičkom karticom ili sa mnogo memorije ili velikim RAM-om

# ANOVA test za cpu_tier obeležje

```{r}
anova_cpu = aov(price ~ cpu_tier, data = datav2)
summary(anova_cpu)
```

Vrednost p je veoma mala, mnogo manja od praga značajnosti 0.05, što znači da se prosečne cene uređaja među grupama značajno razlikuju i to nije slučajno. Takođe F vrednost je veoma velika, što je ova vrednost veća, razlike između grupa su jače.

# 2) Grafik cene u odnosu na rang grafičke kartice

```{r}
ggplot(datav2, aes(x = gpu_tier, y = price)) +
  geom_boxplot(fill = "tomato") +
  labs(title = "Cena u odnosu na GPU Tier",
       x = "GPU Tier", y = "Cena (USD)") +
  theme_minimal()
```

Boxplot-ovi nam pokazuju da je ovaj prediktor još važniji za cenu, medijane takođe pravilno rastu sa povećanjem ranga procesora
niži rangovi (1 i 2) uglavnom ne prelaze neki srednji cenovni rang, kao i za prethodno uređaji većih rangovima sa velikim cenama su neke profesionalne radne stanice ili neki jako dobri gaming uređaji
takođe kod nižih rangova nema uređaja koji su mnogo skupi, jer je gpu uglavnom i najskuplja komponenta uređaja (naravno uz procesor)

# ANOVA test za gpu_tier obeležje

```{r}
anova_gpu = aov(price ~ gpu_tier, data = datav2)
summary(anova_gpu)
```

Rezultati testa su slični kao i za prethodno obeležje, čak je F value malo veća, što nam i za ovo obeležje pokazuje da ima statistički značajan uticaj na cenu uređaja.

# 3) Grafik cene u odnosu na vrste operativnog sistema

```{r}
ggplot(datav2, aes(x = os, y = price)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "Cena u odnosu na operativni sistem",
       x = "Operativni sistem", y = "Cena (USD)") +
  theme_minimal()
```

Boxplot-ovi nam pokazuju da uređaji sa mac operativnim sistemom imaju ubedljivo najvišu medijanu i takođe imaju i velik cenovni opseg tako da su njihovi uređaji ubedljivo najskuplji
uređaji sa windows operativnim sistemom imaju i najveći cenovni opseg, najviše uređaja i koristi ovaj os i postoji gomila uređaja od najjeftinijih do najskupljih
uređaji sa chrome operativnim sistemo imaju najmanju medijanu i najmanji broj outlier-a i to su uglavnom uređaji sa slabijim i jeftinijim komponentama i služe za obavljanje osnovnih zadataka, obrazovanje i slično
uređaji sa linux os-om su uglavnom stabilni i nižih cena, većih od chrome os-a, ali ne sa nešto prezahtevnim hardverom
ovaj prediktor i nije toliko jako povezan sa cenom kao prethodni, ali je dobar pokazatelj kakva je cena u odnosu na neku kategoriju

# 4) Grafik cene u odnosu na veličinu ram memorije

```{r}
ggplot(datav2, aes(x = ram_gb, y = price)) +
  geom_point() +
  labs(title = "Cena u odnosu na veličinu ram memorije",
       x = "Veličina RAM-a", y = "Cena (USD)") +
  theme_minimal()
```

RAM nam predstavlja dobar prediktor cene, jer RAM prati trend što više rama to 
više para. Takvu odliku možemo videti i sa grafika, gde možemo jasno primetiti 
da donja granica raste sa porastom RAM-a. Možemo takođe primetiti da smo ostavili 
određeni broj outliera iz razloga što RAM nije najbitniji prediktor i te ekstremnije 
vrednosti nam znače za predviđanje cene kroz druge prediktore.

# 5) Grafik cene u odnosu na broj jezgara procesora

```{r}
ggplot(datav2, aes(x = factor(cpu_cores), y = price)) +
  geom_boxplot(fill = "skyblue", color = "darkblue", outlier.alpha = 0.25) +
  labs(
    title = "Cena uređaja u odnosu na broj jezgara procesora",
    x = "Broj jezgara",
    y = "Cena (USD)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  )
```

Broj jezgara unutar procesora nam predstavlja dobar prediktor jer ima dobru linearnu korelaciju 0.73, što se može videti iz matrice korelacije. Takođe, na grafiku isto možemo primetiti da sa porastom broja jezgara cena uglavnom raste, ali to nije uvek slučaj, medijane od uređaja sa 20, 26 ili 28 jezgara baš i ne prate trend rasta cene. Vidimo da imamo outliere koje nismo sklonili, jer je potrebno ispitati od kojih još prediktora zavisi cena i outlier-i su uglavnom u normalnim granicama. Sa grafika se može primetiti da sve vrednosti idu za po 2 (4, 6, 8, 10, …) do 20 i onda imamo skok na 24. Razlog tome nije što ne postoje procesori sa 22 jezgra, nego u ovom konkretnom dataset-u nije zabeležen ni jedan procesor sa 22 jezgra.

# 6) Grafik cene u odnosu na proizvođača uređaja

```{r}
ggplot(datav2, aes(x = brand, y = price)) +
  geom_boxplot(fill = "lightblue", outlier.alpha = 0.4) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Cena u odnosu na brend uređaja",
    x = "Brend",
    y = "Cena (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Boxplot-ovi sa slike iznad nam pokazuju da se proizvođač Apple dosta izdvaja od ostalih i njegova medijana je znatno veća
Apple dosta pored komponenti naplaćuje i brand, pa je i logično da bude ovako, pored ove i Razer malo odskače sa medijanom, kao jeftinija marka od Apple, ali skuplja od svih ostalih
Razer uređaji su uglavnom gejmerski pa je i logično što imaju veću cenu, ostale marke nude uređaji raznih cena od najjeftinijih do najskupljih, što je najviše povezavano sa komponentama, a ne samim brendom
Acer je jedini koji ima manju medijanu, jer on najčešće nudi uređaje niske i srednje klase

# 7) Grafik cene u odnosu na vrstu uređaja

```{r}
ggplot(datav2, aes(x = device_type, y = price)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Cena laptopova i desktop računara",
       x = "Tip uređaja", y = "Cena (USD)") +
  theme_minimal()
```

Boxplot-ovi iznad pokazuju da su laptopovi skuplji od računara, što smo i ranije zaključili
medijana im je veća i imaju više cena koje odskaču nego računari, ali je to sasvim normalno, laptopovi imaju integrisane komponente, drugačiji sistem hlađenja, prenosivi su i slično
jednak nivo performansi kod laptopova i računara uvek će laptopovi biti skuplji, kod oba tipa cene koje odskaču su uglavnom gaming uređaji i profesionalni modeli i u sasvim su realnom opsegu

# 8) Uticaj VRAM memorije i ranga grafičke kartice na cenu uređaja

```{r}
ggplot(datav2, aes(x = vram_gb, y = price, color = factor(gpu_tier))) +
  geom_jitter(alpha = 0.6, width = 0.3) +
  scale_color_viridis_d() +
  labs(
    title = "Uticaj VRAM memorije i ranga grafičke kartice na cenu uređaja",
    x = "VRAM (GB)",
    y = "Cena (USD)",
    color = "GPU tier"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.minor = element_blank()
  )
```

Sa grafika iznad možemo videti da su u odnosu na isti ovaj grafik pre brisanja podataka, sklonjeni jeftiniji uređaji sa većim rangovima gpu-a i da su sklonjeni dosta skupi uređaji najvišeg ranga grafičke kartice, a sa veoma malo VRAM-a. Ovaj grafik je pregledniji i pokazuje veću povezanost između ova dva obeležja.

# 9) Uticaj ranga procesora i ranga grafičke kartice na cenu

```{r}
ggplot(datav2, aes(x = cpu_tier, y = price, color = gpu_tier)) +
  geom_point(alpha = 1/3) +
  facet_wrap(~ gpu_tier) +
  theme_minimal() + labs(
    title = "Uticaj ranga procesora i ranga grafičke kartice na cenu",
    x = "Rang procesora (tier)",
    y = "Cena u dolarima"
  )
```

Na grafiku iznad je prikazan uticaj ranga procesara i ranga grafičke kartice na cenu. 
Možemo videti da posle čišćenja podata imamo manje outliera. Znamo da su rang 
procesora i rang grafičke kartice dosta dobri prediktori. To možemo videti sa matrice
korelacija, gde rang procesora ima linearnu zavisnost od 0.77 i rang grafičke kartice 0.78. 
Na ovom grafiku možemo videti da imaju i međusobnu zavisnost i to nam takođe potvrđuje
i matrica zavisnosti 0.86. Tako da možemo razmatrati korišćenje samo jednog od ova 
2 prediktora za predikciju cene u modelu.

# FEATURE SELECTION

```{r}
datav3 = datav2
str(datav3)
```

# Uklanjanje modela

```{r}
datav3$model = NULL
```

Prva kolona koja nam ne pomaže kod predikcije je model. Ta kolona sadrži nazive modela 
nekog uređaja. Tu vrstu podataka ne možemo iskoristiti za treniranje i predikciju cene, jer 
modela ima mnogo. Kada bismo trenirali model nad tim podacima, on ne bi mogao ništa da zaključi 
i kada bi se pojavio model koji nije bio u trening skupu, naš model bi napravio veliku grešku, 
Bolji prediktor nam predstavlja brend, iako je nepreciznija predikcija samo preko brenda, 
barem neće naš model da „preuči“, tj. da bude overfittovan na trening skupu.

# Uklanjanje gpu_model-a, form_factor-a, display_type, display_size_in, wifi, bluetooth i weight_kg

```{r}
datav3$gpu_model = NULL
datav3$form_factor = NULL
datav3$display_type = NULL
datav3$display_size_in = NULL
datav3$wifi = NULL
datav3$bluetooth = NULL
datav3$weight_kg = NULL
```

# Provera za garanciju

```{r}
ggplot(data = datav3) + geom_point(mapping = aes(x = warranty_months, y = price))
```

Garancija ostaje jer se vidi da sa porastom garancije smanjuje se cena

Sa komandom str se može videti celokupna struktura skupa podataka nako FS faze

```{r}
str(datav3)
```

# FEATURE ENGINEERING

# 1)

Kao prvi feature koji bismo mogli dodati jeste upravo cpu_power_score koji predstavlja kolika je zapravo sirova snaga naseg procesora to ćemo dobiti kombinacijom broja jezgara procesora i osnovne frekvencije procesora i nakon dodavanja crtamo grafik

```{r}
datav3$cpu_power_score = datav3$cpu_cores * datav3$cpu_base_ghz

ggplot(datav3, aes(x = cpu_power_score)) +
  geom_histogram(bins = 60, fill = "steelblue", alpha = 0.7, color = "black") +
  labs(
    title = "Distribucija CPU Power Score",
    x = "CPU Power Score (cores × GHz)",
    y = "Broj uređaja"
  ) +
  theme_minimal()
```

Grafik iznad pokazuje da se, kako je i očekivano, najveći broj računara nalazi u delu do 40 score-a, najčešće uređaji imaju po 8 ili 16 jezgara, sa 2.5 do 2.8 GHz snage procesora manji broj uređaja ima score preko 60 što su upravo high-end računari, profesionalni laptopovi i slično

```{r}
ggplot(datav3, aes(x = cpu_power_score, y = price)) +
  geom_point(alpha = 0.3, color = "darkred") +
  labs(
    title = "Odnos CPU Power Score-a i cene uređaja",
    x = "CPU Power Score",
    y = "Cena (USD)"
  ) +
  theme_minimal()
```

Grafik zavisnosti cene od novog feature-a, može se primetiti da cena blago raste sa povećanjem score-a, ali ne preterano, postoji dosta outlier-a posebno u delu od 25 do 50 score-a moglo bi se ovo podeliti u nekoliko kategorija, što bi se svelo na kolonu cpu_tier, pa to nećemo raditi

```{r}
cor(datav3$cpu_power_score, datav3$price)
```

Korelacija je jaka i dobra, malo manja od cpu_tier pre pretvaranja u factor, ovaj prediktor je svakako dobar i nećemo ovo pretvarati u kategorije pošto vec imamo cpu tier koji je ordinal factor promenljiva cpu power score nije zamena za cpu tier, već je komplementaran numerički pokazatelj procesorske snage, za svaku od 6 kategorija iz cpu tier postoje uređaji i sa većom i sa manjom vrednošću novog prediktora, tako da se ne dupliraju podaci

# 2)

Kao drugi feature u okviru fe-a bismo mogli dodati kombinaciju verovatno dva najbitnija obeležja na osnovu dosadašnjih analiza i na osnovu domenskog znanja, a to su cpu tier i gpu tier procesor je osnovna stvar u uređaju sa kojom je sve povezano, a grafička kartica je najbitnija za performanse uređaja, pošto imamo raspoređene uređaje po rangu za oba ova pojedinačno zanima nas kakav će ishod biti kada se spoje

```{r}
datav3$cgt_score = as.numeric(datav3$cpu_tier) * as.numeric(datav3$gpu_tier)
```

Pošto su cpu tier i gpu tier ranije još promenjeni u ordinalne factor promenljive koristimo njihovu nummeričku vrednost kako bismo ih pomnožili

```{r}
ggplot(datav3, aes(x = cgt_score)) +
  geom_histogram(fill = "steelblue", bins = 40, color = "black", alpha = 0.7) +
  labs(
    title = "Distribucija Combined GPU–CPU Tier Score (CGT)",
    x = "CGT Score",
    y = "Broj uređaja"
  ) +
  theme_minimal()
```

Pošto su za oba obeležja klase od 1 do 6, ovaj score ima vrednosti od 1 do 36, izuzetno je rupičast, tačnije dosta vrednosti nema, što je u redu, većina vrednosti je grupisana oko nekih delova vrednosti sa dosta velikim score-om ima malo, to su uglavnom profesionalni uređaji, a i većina našeg skupa podataka jesu upravo računari srednje i niže klase, zato njih i ima najviše

```{r}
ggplot(datav3, aes(x = cgt_score, y = price)) +
  geom_point(alpha = 0.3, color = "darkred") +
  labs(
    title = "Odnos CGT Score-a i cene uređaja",
    x = "CGT Score",
    y = "Cena (USD)"
  ) +
  theme_minimal()
```

Na grafiku zavisnosti cene od cgt score-a cena postepeno raste kako raste i cgt score, outlieri su prisutni u većini score-ova i sasvim su realni, outlieri koji se malo više ističu u srednjoj klasi, najčešće je dosta veća cena posledica količine RAM memorije i njenog tipa

```{r}
cor(datav3$cgt_score, datav3$price)
```

Korelacija je izuzetno visoka, najveća je od svih prediktora do sad, najbolji je pojedinačni prediktor, tako da itekako ga zadržavamo

# 3)

Kada smo uklanjali višak kolone većinom smo sve kolone tipa „model“ uklonili jer postoji 
mnogo modela i nemoguće je izvući znanje iz njih. Međutim, ostavili smo jednu kolone te vrste, 
a to je cpu_model. Ostavili smo ovu kolonu iz razloga što uz malo kreativnosti možemo izvući 
generaciju svakog procesora i napraviti neku vrstu tier-a tj. ranga tih procesora na osnovu 
svoje generacije.

Imamo tri proizvođača procesora, a to su Intell, AMD i Apple. Kod Intell-a se generacije 
označavaju sa „i“ nakon čega sledi broj koji označava generaciju, npr. i3, i5, i7, i9. AMD
označava svoje generacije samo jednim brojem, kao što su 3, 5, 7, 9. Apple za generaciju 
koristi oznaku M, i onda broj iz intervala od 1 do 3, nakon toga ima dodatnu oznaku Pro ili
Max, koji bliže označavaju taj model i svoje sposobnosti.

Kako su tri različita proizvođača, nije baš moguće direktno uporediti generacije, ali je 
moguće to uraditi približno. U suštini, Intell i AMD koriste sličnu oznaku za generaciju i
moguće ih je lako uporediti. Intell i5 je po performansama sličan AMD Ryzen 5, Intell i3 je
sličan AMD Ryzen 3, i tako dalje. Budući da Apple drugačije označava generacije svojih 
procesora, moraćemo malo kreativnije poređenje da napravimo. Pretpostavićemo da M1 = i3 = 3, M2 = i5 = 5, M3 = i7 = 7 i procesori sa oznakama Pro ili Max su jednake i9 i 9.

Podela procesora po generacijama

```{r}
datav3 = datav3 %>% mutate(cpu_generation = case_when( 
    str_detect(cpu_model, regex("i9|Ryzen 9|Pro|Max", ignore_case = FALSE)) ~ 4,
    str_detect(cpu_model, regex("i3|Ryzen 3|M1", ignore_case = FALSE)) ~ 1, 
    str_detect(cpu_model, regex("i5|Ryzen 5|M2", ignore_case = FALSE)) ~ 2, 
    str_detect(cpu_model, regex("i7|Ryzen 7|M3", ignore_case = FALSE)) ~ 3, 
    TRUE ~ NA_real_ 
  ))
```

Distribucija generacije procesora

```{r}
ggplot(datav3, aes(x = cpu_generation)) +
  geom_histogram(fill = "steelblue", bins = 4, color = "black", alpha = 0.7) +
  labs(
    title = "Distribucija generacije procesora",
    x = "Generacija procesora",
    y = "Broj uređaja"
  ) +
  theme_minimal()
```

Na grafiku iznad možemo videti raspodelu generacije procesora. Na osnovu raspodele 
zaključujemo da je naša pretpostavka bila pun pogodak. Vidimo da generacije 2 i 3 ima 
najviše, što prati praksu, gde ljudi najčešće kupuju uređaje sa procesorima iz srednjeg 
nivoa. To su npr. Intell i5 i u malo ređim slučajevima Intell i7. Generacije 1 i 4 dosta 
manje ljudi kupuje, što je i potpuno logično. Procesor kao što je Intel i3 je dosta slab i 
polako gubi svoju upotrebu, dok procesor Intell i9 je ipak previše skup za većinu ljudi.

```{r}
ggplot(datav3, aes(x = cpu_generation, y = price)) +
  geom_point(alpha = 0.3, color = "darkred") +
  labs(
    title = "Odnos generacije procesora i cene uređaja",
    x = "Generacija procesora",
    y = "Cena (USD)"
  ) +
  theme_minimal()
```

Sa Scatter dijagrama iznad možemo dodatno potvrditi da smo pravilnu pretpostavku napravili 
pri inženjeringu kolone o generaciji procesora. Na osnovu donjih granica vidimo da generacije 
prate pozitivni trend, gde viša generacija ima skuplju cenu. Ono što takođe možemo primetiti 
je da generacije 2 i 3 imaju nekoliko netipičnih vrednosti, što nam može govoriti o tome da je 
možda bio malo precizniji način da razdvojimo podatke ili nam takođe može govoriti da cena u 
tim rangovima zavisi dosta više od ostalih komponenti.

```{r}
cor(datav3$cpu_generation, datav3$price) 
```

Vidimo da je korelacija između, novokreiranog prediktora, cpu_generation i cene 0.71. To 
je odlična korelacija i označava nam da bi generacija procesora bila dobar prediktor za cenu uređaja.

Na osnovu svih iscrtanih grafika i korelacije, zaključujemo da nam je cpu_generation dovoljno 
dobar prediktor i da ćemo ga iz tog razloga zadržati za fazu treniranja i testiranja modela mašinskog učenja.

Poslednje što treba uraditi je prebaciti generaciju procesora u kategorijsku promenljivu. Vidimo da ima četiri nivoa (1, 2, 3, 4), tako da ćemo napraviti ordinalnu kategorijsku promenljivu, gde će 1 biti najniža vrednost i 4 biti najviša.

```{r}
datav3$cpu_generation = factor(
  datav3$cpu_generation,
  levels = sort(unique(datav3$cpu_generation)),
  ordered = TRUE
)
```

Sa komandom str se može videti kako izgleda finalna struktura našeg skupa podataka.

```{r}
str(datav3)
```

# PRIPREMA ZA MODELOVANJE 

```{r}
datav4 = datav3
```

Pravimo datav4 što će biti i naš finalni skup podataka

# Logaritamska transformacija

```{r}
datav4$log_price = log1p(datav4$price)

ggplot(datav4, aes(x = log_price)) +
  geom_histogram(bins = 50, fill = "#1f78b4", color = "black", alpha = 0.7) +
  labs(
    title = "Distribucija log-transformisane cene",
    x = "log(1 + price)",
    y = "Broj uređaja"
  ) +
  theme_minimal()
```

Na grafiku iznad se sada može videti kako distribucija cene uređaja izgleda. Ako to 
uporedimo sa slikom raspodele cene od pre, možemo primetiti da sada ekstremno male i ekstremno 
veliki podaci imaju mnogo manji uticaj na njenu raspodelu. Takođe, možemo videti da grafik 
više nije „povučen na desnu stranu“ tj. right skewed, već je vrednost koje ima najviše 
postavljena u centru i sve ostale su oko nje raspoređene.

# Train/test modela

```{r}
set.seed(123)

n = nrow(datav4)

train_index = sample(seq_len(n), size = 0.8 * n)
train_data = datav4[train_index, ]
test_data = datav4[-train_index, ]
```

Sledeće što je potrebno uraditi, je podeliti skup na trening i test skup. Skup ćemo 
podeliti po standardnoj raspodeli: 80:20, gde će 80% biti skup za trening podataka, dok će 
20% skupa biti deo za testiranje, tj. predikciju. Kako bi podela bila najrealnija, postavićemo 
određeni seed, u ovom slučaju je to 123. Nakon toga ćemo samo podeliti indekse na osnovu tog 
seed-a i uspomoć tih indeksa napraviti trening i test skup.

```{r}
nrow(train_data)
nrow(test_data)
```

train podaci su 59376 redova
test podaci su 14845

```{r}
summary(train_data$log_price)
summary(test_data$log_price)
```

Raspodela cene nakon logaritamske transformacije u train i u test skupu je podjednaka
trenira model po jednom rasponu, potrebno da je i test podaci imaju sličan raspon

```{r}
true_price = test_data$price
```

U ovoj promenljivoj čuvamo stvarno cenu uređaja iz testnog skupa

# LINEARNA REGRESIJA

# MODEL 1

```{r}
model_1 = lm(log_price ~ cpu_tier, data=train_data)

pred_1 = expm1(predict(model_1, test_data))

m1_rmse = sqrt(mean((pred_1 - true_price)^2))
m1_mae  = mean(abs(pred_1 - true_price))

m1_rmse; m1_mae

summary(model_1)
```

# MODEL 2

```{r}
model_2 = lm(log_price ~ cpu_tier + gpu_tier, data=train_data)

pred_2 = expm1(predict(model_2, test_data))

m2_rmse = sqrt(mean((pred_2 - true_price)^2))
m2_mae  = mean(abs(pred_2 - true_price))

m2_rmse; m2_mae

summary(model_2)
```

# MODEL 3

```{r}
model_3 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb, data=train_data)

pred_3 = expm1(predict(model_3, test_data))

m3_rmse = sqrt(mean((pred_3 - true_price)^2))
m3_mae  = mean(abs(pred_3 - true_price))

m3_rmse; m3_mae

summary(model_3)
```

# MODEL 4

```{r}
model_4 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score, data=train_data)

pred_4 = expm1(predict(model_4, test_data))

m4_rmse = sqrt(mean((pred_4 - true_price)^2))
m4_mae  = mean(abs(pred_4 - true_price))

m4_rmse; m4_mae

summary(model_4)
```

# MODEL 5

```{r}
model_5 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score, data=train_data)

pred_5 = expm1(predict(model_5, test_data))

m5_rmse = sqrt(mean((pred_5 - true_price)^2))
m5_mae  = mean(abs(pred_5 - true_price))

m5_rmse; m5_mae

summary(model_5)
```

# MODEL 6

```{r}
model_6 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score + storage_gb,
              data=train_data)

pred_6 = expm1(predict(model_6, test_data))

m6_rmse = sqrt(mean((pred_6 - true_price)^2))
m6_mae  = mean(abs(pred_6 - true_price))

m6_rmse; m6_mae

summary(model_6)
```

# MODEL 7

```{r}
model_7 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score + storage_gb + brand,
              data=train_data)

pred_7 = expm1(predict(model_7, test_data))

m7_rmse = sqrt(mean((pred_7 - true_price)^2))
m7_mae  = mean(abs(pred_7 - true_price))

m7_rmse; m7_mae

summary(model_7)
```

# MODEL 8

```{r}
model_8 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score + storage_gb +
                brand + os,
              data=train_data)

pred_8 = expm1(predict(model_8, test_data))

m8_rmse = sqrt(mean((pred_8 - true_price)^2))
m8_mae  = mean(abs(pred_8 - true_price))

m8_rmse; m8_mae

summary(model_8)
```

# MODEL 9

```{r}
model_9 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score + storage_gb +
                brand + os + device_type,
              data=train_data)

pred_9 = expm1(predict(model_9, test_data))

m9_rmse = sqrt(mean((pred_9 - true_price)^2))
m9_mae  = mean(abs(pred_9 - true_price))

m9_rmse; m9_mae

summary(model_9)
```

# MODEL 10

```{r}
model_10 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score + storage_gb +
                brand + os + device_type + cpu_generation,
              data=train_data)

pred_10 = expm1(predict(model_10, test_data))

m10_rmse = sqrt(mean((pred_10 - true_price)^2))
m10_mae  = mean(abs(pred_10 - true_price))

m10_rmse; m10_mae

summary(model_10)
```

# MODEL 11

```{r}
model_11 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score + storage_gb +
                brand + os + device_type + cpu_generation + vram_gb,
              data=train_data)

pred_11 = expm1(predict(model_11, test_data))

m11_rmse = sqrt(mean((pred_11 - true_price)^2))
m11_mae  = mean(abs(pred_11 - true_price))

m11_rmse; m11_mae

summary(model_11)
```

# MODEL 12

```{r}
model_12 = lm(log_price ~ cpu_tier + gpu_tier + ram_gb +
                cpu_power_score + cgt_score + storage_gb +
                brand + os + device_type + cpu_generation + vram_gb + release_year,
              data=train_data)

pred_12 = expm1(predict(model_12, test_data))

m12_rmse = sqrt(mean((pred_12 - true_price)^2))
m12_mae  = mean(abs(pred_12 - true_price))

m12_rmse; m12_mae

summary(model_12)
```

# DODATNA DVA MODELA LINEARNE REGRESIJE

# Delimo podatke na laptopove i računare i za oba skupa podataka treniramo model i vršimo predikciju najbolje što možemo

```{r}
laptopovi = datav4[datav4$device_type == "Laptop",]

racunari = datav4[datav4$device_type == "Desktop",]
```

# MODEL SAMO LAPTOPOVI

```{r}
set.seed(123)

n_lap = nrow(laptopovi)
train_idx_lap = sample(seq_len(n_lap), size = 0.8 * n_lap)

train_lap = laptopovi[train_idx_lap, ]
test_lap  = laptopovi[-train_idx_lap, ]

nrow(train_lap)
nrow(test_lap)

model_lap = lm(log_price ~ cpu_tier + gpu_tier + ram_gb + cgt_score + storage_gb +
                   brand + os + cpu_generation + vram_gb + release_year + charger_watts, data = train_lap)

pred_lap = expm1(predict(model_lap, test_lap))
true_lap = test_lap$price

lap_rmse = sqrt(mean((pred_lap - true_lap)^2))
lap_mae  = mean(abs(pred_lap - true_lap))

lap_rmse
lap_mae

summary(model_lap)
```

Kao i za prethodne modele linarne regresije delimo skup podataka na train i test, treniramo model, predviđamo cenu i računamo RMSE i MAE. Za model smo koristili neke najbitnije prediktore, kao što su bili i za ceo skup podataka, a ideja je bila da se fokusiramo na prediktore vezane samo za laptop, charger_watts se dobro pokazao, za razliku od battery_wh koji nije neki bitan prediktor.

Ovaj model je pokazao veoma dobre rezultate, čak šta više ima najveću vrednost R^2 metrike do sada (ali naravno ovo je samo deo podataka nije ceo skup kao malopre). F statistika je velika i p vrednost je mala što nam ukazuje da smo izabrali uglavnom dobre prediktore. Možemo primetiti i da ovaj model daje najmanju RMSE ~263,4.

# MODEL SAMO RAČUNARI

```{r}
set.seed(123)

n_rac = nrow(racunari)
train_idx_rac = sample(seq_len(n_rac), size = 0.8 * n_rac)

train_rac = racunari[train_idx_rac, ]
test_rac  = racunari[-train_idx_rac, ]

nrow(train_rac)
nrow(test_rac)

model_rac = lm(log_price ~ cpu_tier + gpu_tier + ram_gb + storage_gb +
                 brand + os + vram_gb + release_year + psu_watts, data = train_rac)

pred_rac = expm1(predict(model_rac, test_rac))
true_rac = test_rac$price

rac_rmse = sqrt(mean((pred_rac - true_rac)^2))
rac_mae  = mean(abs(pred_rac - true_rac))

rac_rmse
rac_mae

summary(model_rac)
```

Slično kao i prethodni, ovaj model je dao dobre rezultate metrika, malo niže R^2 od ostalih, ali zato ubedljivo najniža vrednost RMSE i MAE. F statistika i p vrednost su sličnih vrednosti kao i u prošlom modelu što nam pokazuje da je ovo dobar model.

# RANDOM FOREST

Instalacija potrebnog paketa i biblioteke

```{r}
install.packages("ranger", repos = "https://cloud.r-project.org")
library(ranger)
```

Sledeći model, koji ćemo koristiti je Random Forest. Random forest je model mašinskog učenja, 
koji radi pomoću stabla odlučivanja. On sadrži više stabala unutar sebe i „pravi“ šumu, tj. 
povezuje stabla i kroz njih propušta podatke.

Ovaj model deluje kao dobra opcija za predviđanje cene uređaja jer su podaci kod nas takvi da 
je veoma lako pretpostaviti da li je uređaj skuplji ili jeftiniji samo na osnovu marke 
komponente ili operativnog sistema komponente. To se podudara radom stabla odlučivanja.


Treniranje modela

```{r}
rf_model = ranger(
  log_price ~ cpu_tier + gpu_tier + ram_gb +
    cpu_power_score + cgt_score + storage_gb +
    brand + os + device_type + cpu_generation +
    vram_gb + release_year + battery_wh + warranty_months,
  data = train_data,
  num.trees = 500,               
  mtry = floor(sqrt(13)),        
  min.node.size = 5,             
  sample.fraction = 0.75,        
  importance = "impurity",
  seed = 123
)
```

Za treniranje modela korišćeni su prediktori iz najboljeg modela linearne regresije. 
Broj stabala je postavljen na 500, sample.fraction je postavljena na 0.75, to znači da 
će svako drvo videti samo nasumičnih 75% podataka iz trening skupa, zajedno sa tim seed 
je postavljen na 123. Takvom postavkom smo dosta smanjili mogućnost overfittovanja.

Predikcije na test skupu

```{r}
rf_pred = expm1(predict(rf_model, test_data)$predictions)
true_price = test_data$price

rf_rmse = sqrt(mean((rf_pred - true_price)^2))
rf_mae  = mean(abs(rf_pred - true_price))
rf_r2   = 1 - sum((rf_pred - true_price)^2) /
  sum((true_price - mean(true_price))^2)

rf_rmse
rf_mae
rf_r2
```

Na osnovu grafika vidimo da je RMSE malo veći od RMSE kod linearne regresije (266) i takođe 
je MAE malo veći, nego što je to bio slučaj kod linearne regresije (200). Ovo nam ukazuje da 
naš model generalno pravi malo veću grešku u odnosu na linearnu regresiju, ali greška nije 
mnogo velika.

Poslednja metrika je R2 score, sa slike vidimo da model ima R2 score od 0.756, što je malo 
više nego što je bio slučaj kod najboljeg modela linearne regresije (0.755). Zaključak je da 
je ovaj model random forest-a zanemarljivo precizniji od najboljeg modela linearne regresije 
i pravi minimalno veću grešku pri predviđanju. Takođe, možemo zaključiti da je ovaj model 
veoma dobar i prepoznaje trendove u dovoljno preciznoj meri.

Feature importance

```{r}
summary(rf_model)

imp = data.frame(
  feature = names(rf_model$variable.importance),
  importance = rf_model$variable.importance
) %>% arrange(desc(importance))

print(imp)

ggplot(imp, aes(x = reorder(feature, importance), y = importance)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Random Forest Feature Importance",
    x = "Feature",
    y = "Importance"
  ) +
  theme_minimal(base_size = 14)
```

Poslednji deo kod ispitivanja modela je prikazivanje važnosti prediktora, tj. koliko su 
prediktori u stvari imali uticaja u predviđanju cene. Kod linearne regresije je to moguće 
videti komandom summary(), gde bismo onda gledali one zvezdice, koje bi nam rekle koliko je 
taj feature imao uticaja. Ovde smo to prikazali grafički.

Sa grafika možemo videti da je cgt_score imao najveći uticaj i bio je proglašen za najboljeg 
prediktora, što je i za očekivati, sa obzirom na to da je cgt_score imao najveću korelaciju sa 
cenom. Važno je još navesti da operativni sistem i brand nisu imali tolikog uticaja, kao što 
smo u početku pretpostavili da će imati.

# XGBOOST

Instalacija potrebnog paketa i biblioteke

```{r}
install.packages("xgboost", repos = "https://cloud.r-project.org")
library(xgboost)
```

Sledeći model koji ćemo ispitivati je XGBoost. XGBoost je veoma sličan Random Forest-u po 
principu rada, sa određenim promenama. Dok Random Forest koristi više stabala odlučivanja da 
naprave predikciju, XGBoost koristi među stabla koja se bave ispravljanjem greške prethodnog 
stabla odlučivanja. Time se uglavnom dobija bolja preciznost, ali je dosta zahtevnije.

Priprema podataka

```{r}
numeric_cols = names(datav4)[sapply(datav4, is.numeric)]
numeric_cols = setdiff(numeric_cols, c("price", "log_price"))

train_matrix = as.matrix(train_data[, numeric_cols])
test_matrix  = as.matrix(test_data[, numeric_cols])

train_label = train_data$log_price
test_label  = test_data$price    
```

Treniranje modela

```{r}
xgb_model = xgboost( 
  data = train_matrix,
  label = train_label,
  nrounds = 100,
  objective = "reg:squarederror",
  tree_method = "hist",   
  verbose = 0
)
```

Prvo što se primećuje je da postoji deo pripreme podataka, što do sada nije postojalo kod 
linearne regresije i Random Forest-a. U toj pripremi se izdvajaju samo numerički podaci. 
Razlog tome je što XGBoost zahteva da se sve kategorijske promenljive enkodiraju. Međutim, 
pošto nas obojica imamo samo laptopove sa samo 16GB RAM-a, a naš skup ima oko 70.000 podataka 
i 10-ak kategorijskih feature-a, nismo bili u mogućnosti da enkodiramo sve podatke i pokrenemo 
algoritam za trening XGBoost. Odlučili smo da koristimo samo numeričke podatke u predikciji cene.

Predikcija modela

```{r}
xgb_pred_log = predict(xgb_model, newdata = test_matrix)

xgb_pred = expm1(xgb_pred_log)

true_price = test_data$price

xgb_rmse = sqrt(mean((xgb_pred - true_price)^2))
xgb_mae  = mean(abs(xgb_pred - true_price))
xgb_r2   = 1 - sum((xgb_pred - true_price)^2) /
  sum((true_price - mean(true_price))^2)

xgb_rmse
xgb_mae
xgb_r2
```

Vidimo da je RMSE i MAE veoma sličan RMSE i MAE Random Forest-a, gde je XGBoost pravio samo 
malo veću grešku u odnosu na Random Forest. R2 score, tj. preciznost našeg modela je 0.753, 
što je za nijansu niža u odnosu na linearne regresiju i Random Forest. To nije čudno, sa 
obzirom na to da XGBoost nije imao pristup kategorijskim promenljivama. Kada sagledamo sve 
metrike, zaključujemo da je model XGBoost pravio malo višu grešku i samim tim imao za nijansu 
neprecizniju predikciju, ali je model i dalje veoma dobar jer prepoznaje trendove i može biti 
pouzdan u većini slučajeva.

Feature importance

```{r}
xgb_imp_raw = xgb.importance(
  model = xgb_model,
  feature_names = colnames(train_matrix)
)

xgb_imp = xgb_imp_raw %>%
  select(feature = Feature, importance = Gain) %>%
  arrange(desc(importance))

print(xgb_imp)
```

Grafik

```{r}
ggplot(xgb_imp, aes(x = reorder(feature, importance), y = importance)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "XGBoost Feature Importance (Gain)",
    x = "Feature",
    y = "Importance"
  ) +
  theme_minimal(base_size = 14)
```

Kod XGBoost-a smo takođe prikazali važnost prediktora grafički. Sa grafika se vidi veoma 
čudna i neuobičajena situacija. Cgt_score je prikazan kao najbitniji feature, koji sam 
predstavlja 85% bitnosti, dok su svi ostali daleko manje bitni. Tu sad najbolje vidimo 
razliku između XGBoost-a i Random Forest-a. XGBoost je prepoznao da je cgt_score dovoljan 
prediktor i sve ostale je ostavio po strani, tj. koristio je ostale samo kada su mu bili 
neophodni, u onim specifičnim slučajevima.

# LASSO REGRESIJA (L1 Regularizacija)

Poslednji model koji ćemo ispitivati je Lasso. Lasso radi slično linearnoj regresiji, ali za razliku od linearne regresije, Lasso može sam da odabere najbolje prediktore, dodavanjem penala (kazni). Lasso dodaje L1 penal smanjuje koeficijent određenih feature i u nekim slučajevima može da ih postavi na 0, tj. da ih potpuno izbaci.

Instalacija potrebne biblioteke

```{r}
library(glmnet)
```

# Treniranje

```{r}
x = model.matrix(
  log_price ~ cpu_tier + gpu_tier + ram_gb +
    cpu_power_score + cgt_score + storage_gb +
    brand + os + device_type + cpu_generation + vram_gb + release_year,
  data = train_data
)[, -1]

y = train_data$log_price

lasso_model = cv.glmnet(
  x, y,
  alpha = 1,      
  nfolds = 10,
  type.measure = "mse"
)

lasso_model$lambda.min

x_test = model.matrix(
  log_price ~ cpu_tier + gpu_tier + ram_gb +
    cpu_power_score + cgt_score + storage_gb +
    brand + os + device_type + cpu_generation + vram_gb + release_year,
  data = test_data
)[, -1]
```

Na slici iznad se nalazi R kod za treniranje modela Lasso regresije. Korišćena je biblioteka „glmnet“. Pri pozivu glmnet funkcije, potrebno je postaviti alpha na 1, kako bi se radila Lasso regresija i takođe smo podesili da radi sa 10 foldova.

# Predikcija

```{r}
lasso_pred = predict(lasso_model, newx = x_test, s = "lambda.min")
lasso_pred_real = expm1(lasso_pred)

lasso_rmse = sqrt(mean((lasso_pred_real - test_data$price)^2))
lasso_mae  = mean(abs(lasso_pred_real - test_data$price))
lasso_r2   = 1 - sum((lasso_pred_real - test_data$price)^2) /
  sum((test_data$price - mean(test_data$price))^2)

lasso_rmse
lasso_mae
lasso_r2
```

Sa slika iznad možemo videti da su RMSE i MAE dosta slične linearnoj regresiji. Vrednosti su toliko marginalne da nema smisla upoređivati ih na tim metrikama. R2 score je zato dosta bolji od svih modela koje smo testirali do sad. To nam govori o tome da je Lasso mnogo bolje prepoznalo koji prediktori su stvarno važni.

```{r}
lasso_coef = coef(lasso_model, s = "lambda.min")
```

Pretvaranje u data.frame

```{r}
lasso_imp = data.frame(
  feature = rownames(lasso_coef),
  coefficient = as.numeric(lasso_coef)
)
```

Uklanjamo intercept (nije deo feature importance)

```{r}
lasso_imp = lasso_imp %>% filter(feature != "(Intercept)")
```

Apsolutna vrednost koeficijenata = značajnost

```{r}
lasso_imp$importance = abs(lasso_imp$coefficient)
```

Sortiranje opadajuće

```{r}
lasso_imp = lasso_imp %>% arrange(desc(importance))

ggplot(lasso_imp, aes(x = reorder(feature, importance), y = importance)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "LASSO Feature Importance",
    x = "Feature",
    y = "Importance (koeficijent)"
  ) +
  theme_minimal(base_size = 14)
```

Sa grafika vidimo koji su feature-i bili najbitniji kod Lasso regresije. Ono što je interesantno kod ovog grafika je to što je cgt_score postavljen na 0, tj. nije uopšte bitan. Tu primećujemo pravu moć Lasso regresije, gde je prepoznala da je to samo mešavina gpu_tier-a i cpu_tier-a i odbacila ga. Takođe, vidimo da je dosta posmatralo brand da li je Apple, što ostali modeli nisu toliko razmatrali. Na osnovu ovog grafika možemo razumeti kako je Lasso imao bolju predikciju na testnom skupu od ostalih modela.
